---
title: "ドメインロジックと永続化処理を分離する設計改善を行って得られた知見【アカツキ インターン】"
date: 2019-09-16T20:00:00+09:00
draft: false
description: こんにちは、株式会社アカツキでインターンしている@p1assです。今回はインターンのタスクとしてゲーム内仮想通貨管理サービスの設計改善を行った上で分かった、コードの可読性やテスタビリティを向上させる工夫や、実際の作業を行う上で苦労したポイントを紹介します。
categories:
- インターン
tags:
- Go
- GAE
- GCP
- datastore
- アカツキ
eyecatch: /posts/aktsk-intern/ogp.jpg
share: true
---

こんにちは、株式会社アカツキでインターンしている {{< link href="https://twitter.com/p1ass" text="@p1ass" >}} です。

今回はインターンのタスクとしてゲーム内仮想通貨管理サービスの設計改善を行った上で分かった、コードの可読性やテスタビリティを向上させる工夫や、実際の作業を行う上で苦労したポイントを紹介します。

## ゲーム内仮想通貨管理サービスとは

アカツキでは、課金・決済といった各ソーシャルゲームが個々で作るのが大変な機能をサービスとして切り出し、APIとして機能を提供しています。
このサービスにより、ゲーム開発者は**「ゲームを開発する」**という本質的な作業に注力できるようになっています。誤解のないように明記しておきますが、ここで言う「仮想通貨」はBitcoinなどに代表される暗号通貨ではなく、ゲーム内の通貨という意味です。


## 設計改善を行うまでの経緯

今回の移行を行うことになった発端はライブラリ移行でした。

このサービスはGAE/Goな環境で動いていて、データベースにはdatastoreが使われています。そして、datastoreへのアクセスは{{< link href="https://github.com/mjibson/goon" text="mjibson/goon" >}}というライブラリを使っているのですが、これの挙動が怪しいという話がありました。その流れで使用するライブラリを{{< link href="https://github.com/mercari/datastore" text="mercari/datastore" >}}に移行しようという話になり、自分が担当することになりました。

## 現状の課題

実際にライブラリを移行するにあたって既存のコードを読み進めたのですが、大きく2つの問題がありました。

### ドメインロジックとdatastoreへのアクセスが密結合になっている

１つ目がドメインロジックとdatastoreへのアクセスが密結合になっているという問題です。この時の実装では、 `domain` パッケージの中に、実際のドメインロジックとdatastoreへのアクセスが両方書かれていました。インターフェースを用いた抽象化等も一切されておらず、手続き的にコードが書かれていました。そのため、コード量も多く、初めて読んだときはかなり読みづらいと感じました。

### ユニットテストが少なく、インテグレーションテストが多い

2つ目はユニットテストが少なく、インテグレーションテストが多いという問題です。上で述べた通り、密結合になっているせいで、ユニットテストが書きづらく、結果としてインテグレーションテストが多くなっているように見えました。また、インテグレーションを行っているためそれなりのカバレッジが出ているのですが、実際はテストパターンをきちんと網羅できていないように思えました。


## 設計改善

現状の課題を考えると、このままライブラリを移行しようとすると今まで以上に複雑度が増してしまう可能性があります。メンターさんと相談した結果、まずはdatastoreのアクセスを抽象化し、ドメインのロジックと分離してから、ライブラリの移行を行うことにしました。

具体的には、永続化処理を `Respository` インターフェースとして定義し、それを実装するように今までのdatastoreへのアクセス処理を分割しました。DIPで依存関係が逆転することで、 `domain` パッケージでは永続化の詳細を知る必要なくコードが書けることができるようにしました。

最終的には数千行のコードを変更し、リポジトリ全体の1割程度を変更することになりました。

## 設計改善で得られたメリット

今回の設計改善を行うことで、先に述べた2つの課題は解決できました。

### 疎結合な設計にすることができた

密結合になっている問題は、インターフェースを使うことで、疎結合な設計にすることができました。
疎結合な設計と言うと、最近はDDDやClean Architectureなどが流行っていますが、既存のアプリケーションに導入するコストを考えると、ある問題を解決するために必要なテクニックだけを部分的に導入するのは、かなりの効果が見込めると感じました。

### テスタビリティを向上させることができた

永続化処理をインターフェースとして定義することでモックを流し込めるようになり、ユニットテストがとても書きやすくなりました。今までのテストコードはビジネスロジックのテストをするためだけに、事前にdatastoreにデータを流し込んだりしていましたが、モックのおかげでその必要はなくなり、宣言的に返り値を宣言するだけでよくなりました。

{{< highlight go >}}
t.Parallel()

tests := []struct {
    name     string
    money    *types.Money
    injector func(*mocks.MockMoneyRepository) *mocks.MockMoneyRepository
    want     *types.Money
    wantErr  bool
}{
    {
        name: "return error when post failed",
        money: &types.Money{
            MoneyID:  "moneyID",
        },
        injector: func(r *mocks.MockMoneyRepository) *mocks.MockMoneyRepository {
            r.EXPECT().Post(gomock.Any(), gomock.Any()).Return(nil, errors.New("some error"))
            return r
        },
        want:    nil,
        wantErr: true,
    },
    {
        name: "should be success",
        money: &types.Money{
            MoneyID:  "moneyID",
        },
        injector: func(r *mocks.MockMoneyRepository) *mocks.MockMoneyRepository {
            r.EXPECT().Post(gomock.Any(), gomock.Any()).Return(&types.Money{
                MoneyID:  "moneyID",
            }, nil)
            return r
        },
        want: &types.Money{
            MoneyID:  "moneyID",
        },
        wantErr: false,
    },
}
for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        ctrl := gomock.NewController(t)
        defer ctrl.Finish()
        mockRepo := mocks.NewMockMoneyRepository(ctrl)
        mockRepo = tt.injector(mockRepo)
        // ...
    }
}
{{< / highlight>}}


今の時点ではモックを使ったテストは少ないですが、今後モックを使ったユニットテストが増えていき、より堅牢なアプリケーションになっていくでしょう。

### コードの可読性が向上した

永続化処理が抽象化され、ドメイン層では宣言的に呼ぶだけでよくなったことにより、コードがすっきりして可読性が向上しました。ひとつひとつの関数の行数が短くなったことで、なにをするための関数なのかが分かりやすくなりました。

### 将来的にDBを移行することになったときに移行が楽になる

メンターさんと話しているときに、DBを他のGCPのマネージドサービスに移行したいという話がありました。現時点で移行が決まっているわけでないですが、今回の設計改善により将来の移行時により楽に移行ができると思います。


## 設計改善で妥協した点

### 巨大インテグレーションテストを倒せなかった

基本的にインテグレーションテストは、設計改善のタイミングで複数のユニットテストに分割するようにしていました。

しかし、中には複数のドメインロジックやdatastoreの永続化を一気にテストするインテグレーションテストが存在しており、これらを倒すのは一筋縄ではいきませんでした。お金を扱うサービスという性質上、複雑になるのは致し方ないことなので、自分のできる範囲で修正していきました。

しかし残念ながら、ドメインロジックをテストしているにも関わらず実際のdatastoreを使ってテストを行うという、あまりよろしくないテストがいくつか残ってしまいました。ひとまずテスト用のパッケージを作ってテストコードを退避させていますが、将来的にはどうにかしなければいけないと思っています(しかしインターンはもう終了するので自分で直すことはできない)。

## 個人的に得られた知見

### 根拠のある設計は多くのメリットを享受できる

ここからはポエムです。

私は以前からClean Architectureなどのアプリケーションレベルのアーキテクチャに興味を持っており、実際に趣味で開発しているコードでもClean Architectureライクなアーキテクチャを導入してみたりしていました。

その過程で、「ただ冗長な書き方をしているだけでメリットがないのでは？」と思うようになっていました。個人レベルのコードでは嬉しみが見えづらいものなので。


今回のインターンで、メリットを感じられなかったのは、なんとなくアーキテクチャを採用していて、根拠を持っていなかったからだと気づきました。逆に、根拠を持って新たな設計手法を取り入れればより多くのメリットを享受できます。

世の中に山程ある設計手法はなにかしら目的を持って作られています。その目的が自分の開発しているプロダクトとマッチするかを考えて実装することが大事だと感じました。

開発しているプロダクトに本当にClean Architectureは必要なのか？本当に求めているのはDIPだけなのでは？と考え、プロダクトにあった設計を心がけていきたいです。

## まとめ

今回の設計改善を通し、アプリケーションはより分かりやすい設計に出来たと感じています。もちろんこれが完璧だとは考えておらず、まだまだ改善の余地がありますが、一定の効果は得られると思います。これにてインターンは終わってしまいますが、このインターンで得られた知見を今後に生かしていきたいと思います。

最後になりますが、大量のPRをレビューしてくださったメンターさんには感謝しかないです、本当にありがとうございました。


以上、最後までご覧いただきありがとうございました。